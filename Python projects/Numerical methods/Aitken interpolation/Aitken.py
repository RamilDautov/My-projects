import numpy as np
import matplotlib.pyplot as plt

""" Расчет разностных отношений """
def coef(x, y, y_1, y_2):
       '''x : массив значений икс
          y : массив значений игрек
          y_1: массив первых производных
          y_2: массив вторых производных'''
       x.astype(float)
       y.astype(float)
       n = len(x)
       a = []
       for i in range(n):
           a.append(y[i])

       for j in range(1, n):
           for i in range(n-1, j-1, -1):
               if j == 1: #при первом шаге будем вводить первую производную
                   if round(x[i], 3) == round(x[i - j], 3):
                       a[i] = y_1[i] #заменяем на первую производную
                   else:
                       a[i] = float(a[i]-a[i-1])/float(x[i]-x[i-j])
               else: #при втором шаге и последующих нам понадобится вторая производная
                   if round(x[i], 3) == round(x[i - j], 3):
                       f[j] = y_2[j] / 2
                   else:
                       a[i] = float(a[i] - a[i - 1]) / float(x[i] - x[i - j])

       return np.array(a) # возвращаем разностные отношения


""" Расчет интерполяционного значения """
def Eval(a, x, r):
    '''x : массив значений икс
       a : массив разностных отношений
       r: точка, в которой производим интерполяцию '''
    x.astype(float)
    n = len( a ) - 1
    temp = a[n]
    for i in range( n - 1, -1, -1 ):
        temp = temp * ( r - x[i] ) + a[i]
    return temp # возвращаем интерполяционное значение


""" Так как в некоторых узлах мы производим
    интерполяцию до производных второго порядка, то эти узлы вводим кратности 3.
    Соответственно кратности 3 будут значения y, y_1 и y_2 в данных узлах"""
x = np.array([1, 1, 1, 1.3, 1.7, 1.7, 1.7, 2.0, 2.4, 2.4, 2.4, 3.0])
y = np.array([2.598, 2.598, 2.598, 2.643, 2.619, 2.619, 2.619, 2.586, 2.546, 2.546, 2.546, 2.509])
y_1 = np.array([0.0341, 0.0341, 0.0341, 0, -0.0103, -0.0103, -0.0103, 0, -0.0085, -0.0085, -0.0085, 0])
y_2 = np.array([-0.00164, -0.00164, -0.00164, 0, -0.001, -0.001, -0.001, 0, 0, 0, 0, 0])

xval = np.arange(1, 2.5, 0.05) #точки, в которых производим интерполяцию (до 2.5, так как нам нужно 5 точек)

n = np.size(x)
yval = np.zeros(np.size(xval))

f = np.ones(n) #разностные отношения
f = coef(x, y, y_1, y_2) #находим их с помощью функции coef

for u in range(0, np.size(xval)):
    yval[u] = Eval(f, x, xval[u])

plt.scatter(x[:-2], y[:-2], color='r', marker='o', s=25) #здесь x[:-2] и y[:-2], так как по условию задачи n = 5 -- пять точек
plt.scatter(xval, yval, color='g', marker='*', s=10)
plt.show()